---
title: "Cross-checking Native and Invasive Niches"
author: "July Pilowsky"
format: html
editor: visual
---

```{r setup}
library(conflicted)
library(raster)
library(tidysdm)
library(terra)
library(tidyterra)
library(vroom)
library(here)
library(sf)
library(tidyverse)
library(paletteer)
library(furrr)
library(DALEX)
library(climateStability)
conflict_prefer_all("dplyr", quiet = T)
i_am("Scripts/sdm_native_invasive.qmd")
data.dir <- "~/Documents/Very_Large_Data"
proj_crs <- "+proj=aea +lon_0=-94.5 +lat_1=21.5 +lat_2=47.5 +lat_0=34.5 +datum=WGS84 +units=m +no_defs"
wgs84 <- "GEOGCRS[\"WGS 84\",\n    DATUM[\"World Geodetic System 1984\",\n        ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n            LENGTHUNIT[\"metre\",1]],\n        ID[\"EPSG\",6326]],\n    PRIMEM[\"Greenwich\",0,\n        ANGLEUNIT[\"degree\",0.0174532925199433],\n        ID[\"EPSG\",8901]],\n    CS[ellipsoidal,2],\n        AXIS[\"longitude\",east,\n            ORDER[1],\n            ANGLEUNIT[\"degree\",0.0174532925199433,\n                ID[\"EPSG\",9122]]],\n        AXIS[\"latitude\",north,\n            ORDER[2],\n            ANGLEUNIT[\"degree\",0.0174532925199433,\n                ID[\"EPSG\",9122]]]]"
finch_region <- qs::qread(here::here("Data/Input/finch_region.qs"))
ts <- 1940:2016
hofi_sample <- vroom(file.path(data.dir, "hofi_gbif_qc.tsv")) %>% 
  filter(year < 2017) %>% 
  # filter(decimallongitude>-128, decimallongitude<(-61), 
  #        decimallatitude>15, decimallatitude<54, year<2018) %>% 
  group_by(year) %>% group_split()
points <- hofi_sample %>% map(~select(., decimallongitude, decimallatitude)) %>% 
  map(sf_project, from = wgs84, to = proj_crs) %>% 
  map(as.data.frame) %>% 
  map(set_names, nm = c("x", "y")) %>% 
  map(~mutate(., Range = if_else(x<(-373881), "Native", "Invasive"))) %>% 
  set_names(ts) %>% 
  identity()
template <- rast(finch_region$region_raster)
```

# Goal

I want to check whether species distribution models trained on invasive range occurrences vs. native range occurrences are functionally identical, or if the finch's niche is different in each range. I will do this by first training on the native range and projecting into the invasive range, then training on the invasive range and projecting into the native range.

# Prepare Data

To prepare my data for modeling, I will need to complete the following steps:

1.  divide the data into the native and invasive range
2.  spatiotemporally thin them
3.  generate pseudo-absences
4.  pair everything with environmental data

```{r map native and invasive data}
native <- map2(hofi_sample, points, bind_cols) %>% 
  map(~filter(., x > -3741268, x < 3725142, y > -2277277, y < 2638496)) %>% 
  map(~filter(., Range == "Native")) %>% 
  map(st_as_sf, coords = c("x", "y"), crs = st_crs(proj_crs), remove = F)
invasive <- map2(hofi_sample, points, bind_cols) %>% 
  map(~filter(., x > -3741268, x < 3725142, y > -2277277, y < 2638496)) %>% 
  map(~filter(., Range == "Invasive")) %>% 
  map(st_as_sf, coords = c("x", "y"), crs = st_crs(proj_crs), remove = F) %>% 
  identity()
ggplot() +
  geom_spatraster(data = template) +
  guides(fill = "none") +
  geom_sf(bind_rows(native), mapping = aes(col=year), alpha = 0.4) +
  scale_color_paletteer_c(`"pals::ocean.amp"`, name = "Year", direction = -1) +
  ggtitle("Native Range")
ggplot() +
  geom_spatraster(data = template) +
  guides(fill = "none") +
  geom_sf(bind_rows(invasive), mapping = aes(col=year), alpha = 0.4) +
  scale_color_paletteer_c(`"pals::ocean.amp"`, name = "Year", direction = -1) +
  ggtitle("Invasive Range")
```

It is a little difficult to imagine how to generate pseudo-absences when there is such a density of presences. But let's do some thinning first.

```{r spatiotemporal thinning}
native_thin <- native %>% 
  map(thin_by_cell, raster = template, coords = c("x", "y"))
invasive_thin <- invasive %>% 
  map(thin_by_cell, raster = template, coords = c("x", "y"))
native_abs <- native_thin %>% bind_rows() %>% 
  sample_pseudoabs(raster = template %>% 
                     crop(ext(-2448618, -373881, -2277277, 2638496)), 
                   coords = c("X", "Y"),
                   n = 1000, method = c("dist_min", 50000), return_pres = F)
ggplot() +
  geom_spatraster(data = template) +
  guides(fill = F) +
  geom_sf(native_abs, mapping = aes(col=class), alpha = 0.4) +
  ggtitle("Native Range") +
  scale_color_paletteer_d(`"nbapalettes::sixers_retro"`)
invasive_abs <- invasive_thin %>% bind_rows() %>% 
  sample_pseudoabs(raster = template %>% 
                     crop(ext(-373881, 3725142, -2277277, 2638496)),
                   coords = c("X", "Y"),
                   n = 6300, method = c("dist_min", 50000), return_pres = F)
ggplot() +
  geom_spatraster(data = template) +
  guides(fill = F) +
  geom_sf(invasive_abs, mapping = aes(col=class), alpha = 0.4) +
  ggtitle("Invasive Range") +
  scale_color_paletteer_d(`"nbapalettes::sixers_retro"`)
```

Now I need to pair these presences and pseudo-absences with my environmental predictors, which are the 19 bioclim variables plus a land use change index.

```{r extract climate data}
native_points <- native_thin %>% map(~transmute(., class = "presence")) %>% 
  map2(replicate(77, slice_sample(native_abs, n = 100), simplify = F), bind_rows)
invasive_points <- invasive_thin %>% map(~transmute(., class = "presence")) %>% 
  map2(replicate(77, slice_sample(invasive_abs, n = 100), simplify = F), bind_rows)
files2 <- list.files("~/Documents/Very_Large_Data/predictors/CHELSA",
                     pattern = "^predictors_.+",
                     full.names = T) %>% 
  keep(str_detect, pattern = "\\.grd$") %>% set_names(ts)
col_names <- 1:19 %>% as.character() %>% map(~paste0("bio", .)) %>% 
  append("urban") %>% flatten_chr()
plan(multisession)
native_extract <- future_map2(files2, native_points, function(f, p) {
  r <- rast(f); terra::extract(r, p, ID = F)
}, .options = furrr_options(seed = T)) %>% 
  map(~set_names(., col_names)) %>% 
  map2(native_points, bind_cols) %>% 
  list_rbind(names_to = "Year") %>% 
  st_as_sf(sf_column_name = "geometry")
invasive_extract <- future_map2(files2, invasive_points, function(f, p) {
  r <- rast(f); terra::extract(r, p, ID = F)
}, .options = furrr_options(seed = T)) %>% 
  map(~set_names(., col_names)) %>% 
  map2(invasive_points, bind_cols) %>% 
  list_rbind(names_to = "Year") %>% 
  st_as_sf(sf_column_name = "geometry")
native_extract %>% select(-Year) %>% plot_pres_vs_bg(class)
```

This shows that in the native range at least there is some meaningful difference between the presences and the pseudoabsences.

```{r invasive range comparison}
invasive_extract %>% select(-Year) %>% plot_pres_vs_bg(class)
```

# Native SDM

## Fit model

Here we can see the randomly assigned spatial cross-validation folds:

```{r fit native sdm}
native_rec <- native_extract %>% 
  select(-Year) %>% 
  recipe(formula = class ~ .)
native_models <- workflow_set(
  preproc = list(default = native_rec),
  models = list(
    rf = sdm_spec_rf(),
    gbm = sdm_spec_boost_tree()
  ),
  cross = T
) %>% 
  option_add(control = control_ensemble_grid())
native_cv <- spatial_block_cv(native_extract, v = 5, method = "random")
autoplot(native_cv)
```

Here I compare the results from different SDM specifications:

```{r compare fits}
native_models <- native_models %>%
  workflow_map("tune_grid", resamples = native_cv, grid = 20, metrics = sdm_metric_set(),
               verbose = TRUE)
autoplot(native_models)
```

It seems that MaxEnt does really poorly in this situation, and gbm / random forest models do a lot better. I will keep this in mind for the invasive SDM.

## Predict

Let's see the fit of the best models to the presence records across the whole range.

```{r predictions native}
native_ensemble <- simple_ensemble() %>%
  add_member(native_models, metric = "tss_max")
native_ensemble <- qs::qread(here("Data/Input/native_sdm_ensemble.qs")) %>% 
  calib_class_thresh(class_thresh = "tss_max",
                     metric_thresh = c("tss_max", 0.7))
predict_ni_2017 <- native_ensemble %>% 
  predict_raster(
    rast("~/Documents/Very_Large_Data/predictors/predictors_2017.grd") %>% 
      `names<-`(col_names), 
    type = "class",
    fun = "weighted_mean",
    class_thresh = c("tss_max"),
    metric_thresh = c("tss_max", 0.7))
ggplot() + 
  geom_spatraster(data = predict_ni_2017, aes(fill = binary_weighted_mean)) +
  scale_fill_paletteer_d(`"calecopal::superbloom3"`) +
  geom_sf(data = native_extract %>% filter(class == "presence",
                                           Year == "2017"), alpha = 0.1) +
  geom_sf(data = invasive_extract %>% filter(class == "presence",
                                             Year == "2017"), alpha = 0.1) +
  ggtitle("2017")
predict_ni_1940 <- native_ensemble %>% 
  predict_raster(
    rast("~/Documents/Very_Large_Data/predictors/predictors_1940.grd") %>% 
      `names<-`(col_names), 
    type = "class",
    fun = "weighted_mean",
    class_thresh = c("tss_max"),
    metric_thresh = c("tss_max", 0.7))
ggplot() + 
  geom_spatraster(data = predict_ni_1940, aes(fill = binary_weighted_mean)) +
  scale_fill_paletteer_d(`"calecopal::superbloom3"`) +
  geom_sf(data = native_extract %>% filter(class == "presence",
                                           Year == "1940"), alpha = 0.5) +
  geom_sf(data = invasive_extract %>% filter(class == "presence",
                                             Year == "1940"), alpha = 0.5) +
  ggtitle("1940")
```

The model does quite well, though it does over-predict presence in southern Mexico and under-predict presence in Florida.

# Invasive SDM

## Fit model

Here we can see the randomly assigned spatial cross-validation folds:

```{r prep invasive sdm}
invasive_rec <- invasive_extract %>% 
  select(-Year) %>% 
  recipe(formula = class ~ .)
invasive_models <- workflow_set(
  preproc = list(default = invasive_rec),
  models = list(
    rf = sdm_spec_rf(),
    gbm = sdm_spec_boost_tree()
  ),
  cross = T
) %>% 
  option_add(control = control_ensemble_grid())
invasive_cv <- spatial_block_cv(invasive_extract, v = 5, method = "random")
autoplot(invasive_cv)
```

Here I compare the results from different SDM specifications:

```{r tune invasive sdm}
# invasive_models <- invasive_models %>% 
#    workflow_map("tune_grid", resamples = invasive_cv, grid = 20, 
#                 metrics = sdm_metric_set(),
#                 verbose = TRUE)
# autoplot(invasive_models)
```

## Predict

Let's see the fit of the best models to the presence records across the whole range.

```{r predictions invasive}
# invasive_ensemble <- simple_ensemble() %>%
#   add_member(invasive_models, metric = "tss_max")
invasive_ensemble <- qs::qread(here("Data/Input/invasive_sdm_ensemble.qs")) %>% 
  calib_class_thresh(class_thresh = "tss_max",
                     metric_thresh = c("tss_max", 0.7))
predict_in_2017 <- invasive_ensemble %>% 
  predict_raster(
    rast("~/Documents/Very_Large_Data/predictors/predictors_2017.grd") %>% 
      `names<-`(col_names), 
    type = "class",
    fun = "weighted_mean",
    class_thresh = c("tss_max"),
    metric_thresh = c("tss_max", 0.7))
ggplot() + 
  geom_spatraster(data = predict_in_2017, aes(fill = binary_weighted_mean)) +
  scale_fill_paletteer_d(`"calecopal::superbloom3"`)
ggplot() + 
  geom_spatraster(data = predict_in_2017, aes(fill = binary_weighted_mean)) +
  scale_fill_paletteer_d(`"calecopal::superbloom3"`) +
  geom_sf(data = native_extract %>% filter(class == "presence",
                                           Year == "2017"), alpha = 0.1) +
  geom_sf(data = invasive_extract %>% filter(class == "presence",
                                             Year == "2017"), alpha = 0.1) +
  ggtitle("2017")
predict_in_1940 <- invasive_ensemble %>% 
  predict_raster(
    rast("~/Documents/Very_Large_Data/predictors/predictors_1940.grd") %>% 
      `names<-`(col_names), 
    type = "class",
    fun = "weighted_mean",
    class_thresh = c("tss_max"),
    metric_thresh = c("tss_max", 0.7))
ggplot() + 
  geom_spatraster(data = predict_in_1940, aes(fill = binary_weighted_mean)) +
  scale_fill_paletteer_d(`"calecopal::superbloom3"`)
ggplot() + 
  geom_spatraster(data = predict_in_1940, aes(fill = binary_weighted_mean)) +
  scale_fill_paletteer_d(`"calecopal::superbloom3"`) +
  geom_sf(data = native_extract %>% filter(class == "presence",
                                           Year == "1940"), alpha = 0.6) +
  geom_sf(data = invasive_extract %>% filter(class == "presence",
                                             Year == "1940"), alpha = 0.6) +
  ggtitle("1940")
```

Overall the invasive occurrences do a better job of prediction.

# Measure Overlap

Now I can look statistically at how much the predictions from the native and invasive SDMs overlap and get a sense of how analogous they are for the purposes of my models. To do this I will generate predictions for all 78 years of the study based on both SDMs, then graph Schoener's D measure of overlap between them.

```{r overlap}
plan(sequential)
invasive_predict <- files2 %>% future_map(function(f) {
  r <- rast(f) %>% `names<-`(col_names)
  p <- invasive_ensemble %>% 
    predict_raster(
      r,
      fun = "weighted_mean",
      metric_thresh = c("tss_max", 0.7))
}, .options = furrr_options(seed = T))
native_predict <- files2 %>% future_map(function(f) {
  r <- rast(f) %>% `names<-`(col_names)
  p <- native_ensemble %>% 
    predict_raster(
      r,
      fun = "weighted_mean",
      metric_thresh = c("tss_max", 0.7))
}, .options = furrr_options(seed = T))
dismo::nicheOverlap(raster(native_predict[[1]]), raster(invasive_predict[[1]]), 
                    stat = "D",
                    mask = FALSE, checkNegatives = FALSE)
overlap_metric <- map2(native_predict, invasive_predict, 
                       ~dismo::nicheOverlap(raster(.x), raster(.y),
                                            stat = "D",
                                            mask = FALSE, checkNegatives = FALSE))
data.frame(Overlap = flatten_dbl(overlap_metric),
           Year = ts) %>% 
  ggplot(aes(x = Year, y = Overlap)) + geom_line()
```

The overlap is consistently high throughout.

# Full SDM

Now that it is clear that the estimates from the native and invasive SDMs mostly overlap, I feel confident enough to try a SDM with all of the data points and generate habitat suitability maps based on probability of occurrence.

## Fit model

```{r prep full sdm}
full_extract <- native_extract %>% 
  bind_rows(invasive_extract) %>%
  filter(!if_any(everything(), is.na))
full_rec <- full_extract %>% 
  select(-Year) %>% 
  recipe(formula = class ~ .)
full_models <- workflow_set(
  preproc = list(default = full_rec),
  models = list(
    rf = sdm_spec_rf(),
    gbm = sdm_spec_boost_tree()
  ),
  cross = T
) %>% 
  option_add(control = control_ensemble_grid())
full_cv <- spatial_block_cv(full_extract, v = 5, method = "random")
autoplot(full_cv)
```

Here I compare results from different SDM specifications.

```{r tune full sdm}
doParallel::registerDoParallel()
full_models <- full_models %>%
   workflow_map("tune_grid", resamples = full_cv, grid = 20,
                metrics = sdm_metric_set(),
                verbose = TRUE)
autoplot(full_models)
```

I want to take a moment to explore the variable importance and partial dependence plots because I'm interested in the effect of urbanization on presence.

```{r explain}
full_ensemble <- simple_ensemble() %>%
  add_member(full_models, metric = "boyce_cont")
qs::qsave(full_ensemble, here("Data/Input/full_sdm_ensemble_v2.qs"))
# full_ensemble <- qs::qread(here("Data/Input/full_sdm_ensemble.qs"))
full_explainer <- explain_tidysdm(full_ensemble, verbose = F)
full_explainer %>%
  model_parts() %>% 
  plot()
```

Clearly, urbanization is the most important predictor of presence for the house finch, followed by temperature seasonality and mean annual temperature.

Now I want to look at the partial dependence profile for urbanization.

```{r pd}
full_explainer %>% 
  model_profile(variables = "urban", N = 2000) %>% 
  plot() + ggtitle("Partial dependence profile for urbanization")
```

This appears to be a threshold effect: some minimal amount of urbanization is required for house finches to be present.

## Predict

Here I have the specific goal of producing a stack of habitat suitability maps to use for simulations later. First I will test one year, 1960, to see how it looks.

```{r predict 1960}
predict1960 <- full_ensemble %>% 
  predict_raster(
    rast("~/Documents/Very_Large_Data/predictors/CHELSA/predictors_1960.grd") %>% 
      `names<-`(col_names), 
    type = "prob",
    fun = "weighted_mean",
    metric_thresh = c("tss_max", 0.7))
ggplot() + 
  geom_spatraster(data = predict1960, aes(fill = weighted_mean)) +
  scale_fill_paletteer_c(`"scico::bamako"`, direction = -1) +
  geom_sf(data = native_extract %>% filter(class == "presence",
                                           Year == "1960"), alpha = 0.3) +
  geom_sf(data = invasive_extract %>% filter(class == "presence",
                                             Year == "1960"), alpha = 0.3) +
  ggtitle("Probability of occurrence 1960")
```

This looks pretty good, but two things have to happen first: the predictions have to be masked to the extent of the study area, and I have to scale these values from 0 to 1.

```{r predict stack}
suitability <- map(files2, rast) %>% 
  map(function(r) {predict_raster(object = full_ensemble,
                      raster = r %>% `names<-`(col_names),
                      type = "prob",
                      fun = "weighted_mean",
                      metric_thresh = c("boyce_cont", 0.95))}) %>% 
  map(mask, mask = template) %>% 
  rast() |> rescale0to1()
# Rasterization of the coastline landed Jones Beach in the ocean so it has to be
# interpolated back in so the house finches can be introduced there
adjacent(suitability, 6075, 8) |> as.vector() -> indices
for (l in 1:nlyr(suitability)) {
  suitability[[l]][6075] <- suitability[[l]][indices][,1] |> mean(na.rm = T)
}
terra::writeRaster(suitability, here("Data/Input/habitat_suitability_v3.tif"))
```
