---
title: "Friction Landscapes"
author: "July Pilowsky"
format: html
editor: visual
---

```{r setup}
library(raster)
library(elevatr)
library(tidyverse)
library(cowplot)
library(paletteer)
library(furrr)
library(terra)
library(sf)
library(here)
proj_crs <- "+proj=aea +lon_0=-94.5 +lat_1=21.5 +lat_2=47.5 +lat_0=34.5 +datum=WGS84 +units=m +no_defs"
finch_region <- qs::qread(here::here("Data/Input/finch_region.qs"))
```

# Goal

My goal is to develop several hypothesized friction landscapes for the dispersal of house finches. These will arise from some combination of elevation and urbanization data, based on findings in the literature that elevation impedes disease spread and urbanization facilitates it.

# Elevation Data

I have a quality-controlled selection of GBIF occurrences for the house finch. I want to investigate the elevation of these occurrences.

```{r elevation, message = F}
hofi <- read_tsv("~/Documents/Very_Large_Data/gbif_hofi_predictors.csv")
elev <- hofi %>% select(x = decimallongitude, y = decimallatitude) %>% 
  as.data.frame() %>% 
  get_elev_point(prj = "+proj=longlat +ellps=WGS84", src = "aws") %>% 
  as.data.frame() %>% 
  select(-geometry)
ggplot(elev, aes(x = elevation)) + geom_density() + theme_minimal_vgrid() +
  xlab("Elevation (m)")
```

Clearly most house finches are found at sea level. It might be helpful to compare this against background points in the house finch range.

```{r elevation comparison, message = FALSE}
hofi_bg <- read_tsv("~/Documents/Very_Large_Data/hofi_background_points.csv")
elev_bg <- hofi_bg %>% select(x, y) %>% 
  as.data.frame() %>% 
  get_elev_point(prj = proj_crs, src = "aws") %>% 
  as.data.frame() %>% 
  select(-geometry)
elev %>% mutate(Range = "House Finch") %>% 
  bind_rows(elev_bg %>% mutate(Range = "Background")) %>% 
  ggplot(aes(x = elevation, fill = Range)) +
  geom_density(alpha = 0.4) +
  theme_minimal_vgrid() +
  scale_fill_paletteer_d("suffrager::classic") +
  xlab("Elevation (m)")
```

So clearly the house finch prefers low elevation more so than we would expect by chance.

# Urbanization Data

Thankfully, I have already extracted urbanization data for the house finch occurrence points and the background points.

```{r urban, warning = F}
hofi %>% mutate(Source = "House Finch") %>% 
  bind_rows(hofi_bg %>% mutate(Source = "Background")) %>% 
  ggplot(aes(x = urban, fill = Source)) + geom_density(alpha = 0.4) +
  xlab("Urbanization Index") +
  scale_fill_paletteer_d("suffrager::classic") +
  theme_minimal_vgrid() +
  scale_x_log10()
```

The house finch also clearly prefers urban environments more than would be expected by chance.

I'm also curious about how these two interact. Does urbanization allow the house finch to invade altitudes it normally couldn't?

```{r elevation + urbanization}
hofi %>% mutate(Source = "House Finch") %>% 
  bind_rows(hofi_bg %>% mutate(Source = "Background")) %>% 
  bind_cols(bind_rows(elev, elev_bg)) %>% 
  group_by(Source) %>% 
  slice_sample(n = 200000) %>% 
  ggplot(aes(x = elevation, y = urban)) + geom_hex() +
  scale_fill_paletteer_c("pals::ocean.amp", trans = "log10") +
  theme_minimal_grid() +
  facet_grid(~Source)
```

# Friction Landscapes

I am going to create three friction landscapes: one with only urbanization, one with only elevation, and one that incorporates both.

## Elevation Friction Landscape

I want to make an elevation friction landscape. This is a little complex because elevation does not go from 0 to 1, as shown:

```{r elevation raster}
elev_raster <- get_elev_raster(finch_region$region_raster, z = 4) %>% 
  crop(finch_region$region_raster) %>% 
  resample(finch_region$region_raster) %>% 
  mask(finch_region$region_raster)
plot(elev_raster)
```

What I am going to do is truncate everything to a 0 m to 3000 m range (rounding things slightly below sea level up to 0, rounding things above 3 km down to 3 km) and I will scale this interval to 1 conductance at sea level and 0 conductance at 3 km.

```{r elevation friction}
elev_matrix <- elev_raster[] %>% 
  scales::rescale(to = c(1, 0), from = c(0, 3000))
elev_matrix[elev_matrix<0] <- 0
elev_matrix[elev_matrix>1] <- 1
elev_friction <- finch_region$raster_from_values(elev_matrix %>% discard(is.na(.)))
plot(elev_friction)
```

## Urban Friction Landscape

Urbanization is an index that goes from 0 to 1, and I expect the highest conductance with the highest urbanization.

```{r urban friction}
urban_raster <- "~/Documents/Very_Large_Data/predictors" %>% 
  list.files(pattern = "*.grd$", full.names = TRUE) %>% 
  map(rast, lyrs = 20) %>% 
  rast() %>% 
  mask(rast(finch_region$region_raster))
urban_matrix <- as.matrix(urban_raster) %>% 
  # scales::rescale() %>% 
  identity()
urban_friction <- map(1:78, function(i) {
  finch_region$raster_from_values(urban_matrix[, i] %>% discard(is.na(.)))
}) %>% stack()
plot(urban_friction[[78]])
```

This landscape is rather sparse. Mostly, the birds cannot disperse, because the urbanized areas are like little islands in a sea of nothing. I am going to address this by adding a kernel density estimation to each urbanized grid cell. Here I use an Epanechnikov kernel density estimator with a bandwidth of 100 km.

```{r kde2d}
urban_dfs <- map(1:78, function(i) {
  finch_region$coordinates %>%
    cbind(urbanization = urban_matrix[finch_region$region_indices, i]) %>% 
    filter(urbanization > 0) %>% 
    st_as_sf(coords = c("x", "y"), crs = st_crs(proj_crs))
})
# plan(multisession)
# urban_friction <- future_map(1:78, function(i) {
#   kde(urban_dfs[[i]], band_width = 100000, kernel = "epanechnikov", 
#             weights = urban_dfs[[i]]$urbanization, grid = finch_region$region_raster) %>% 
#   mask(finch_region$region_raster)
# }) %>% stack()
# urban_scaled <- scales::rescale(values(urban_friction)) %>% .[finch_region$region_indices,] %>%
#   finch_region$raster_from_values()
urban_scaled <- stack(here("Data/Input/urban_friction_landscape.grd"))
plot(urban_scaled[[78]])
```

## Urban + Elevation Friction

Finally, I want to make a friction landscape that includes both factors, multiplied together.

```{r urban + elevation}
full_friction <- map(1:78, function(i) {
  mat <- as.matrix(urban_scaled) * elev_matrix
  finch_region$raster_from_values(mat[, i] %>% discard(is.na(.)))
}) %>% stack()
plot(full_friction[[1]])
```
