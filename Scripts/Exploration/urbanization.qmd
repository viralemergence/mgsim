---
title: "What is Urbanization to a Finch?"
author: "July Pilowsky"
format: html
editor: visual
---

```{r setup, include = F, message = F}
library(conflicted)
library(tidyverse)
library(terra)
library(tidyterra)
library(here)
library(paletteer)
library(furrr)
library(vroom)
library(rgbif)
library(sf)
library(tidysdm)
conflicts_prefer(tidyterra::filter)
conflicts_prefer(terra::extract)
conflicts_prefer(purrr::discard)
conflicts_prefer(terra::subset)
source(here("Scripts/convenience_functions.R"))
wgs84 <- "GEOGCRS[\"WGS 84\",\n    DATUM[\"World Geodetic System 1984\",\n        ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n            LENGTHUNIT[\"metre\",1]],\n        ID[\"EPSG\",6326]],\n    PRIMEM[\"Greenwich\",0,\n        ANGLEUNIT[\"degree\",0.0174532925199433],\n        ID[\"EPSG\",8901]],\n    CS[ellipsoidal,2],\n        AXIS[\"longitude\",east,\n            ORDER[1],\n            ANGLEUNIT[\"degree\",0.0174532925199433,\n                ID[\"EPSG\",9122]]],\n        AXIS[\"latitude\",north,\n            ORDER[2],\n            ANGLEUNIT[\"degree\",0.0174532925199433,\n                ID[\"EPSG\",9122]]]]"
proj_crs <- "+proj=aea +lon_0=-94.5 +lat_1=21.5 +lat_2=47.5 +lat_0=34.5 +datum=WGS84 +units=m +no_defs"
```

# Goal

To break down exactly what about urbanization is biologically relevant to the house finch, and how it might affect habitat suitability and dispersal.

# Components of Land Use Change

## Urban area

Currently, the raster of urbanization I have been using has been based on strictly urban land area (towns and cities). I show this here.

```{r strict urban}
bbox <- ext(-128, -61, 15, 54)
source_time <- c(1940, 1950, 1960, 1970, 1980, 1990, 2000, 2001:2017)
target_time <- c(1940:2017)
urb1 <- "~/Documents/Very_Large_Data/baseline/zip/" %>%
  list.files(full.names = TRUE, include.dirs = TRUE) %>%
  discard(str_detect, pattern = "\\.zip") %>%
  keep(str_detect, pattern = "pop") %>%
  map(list.files, full.names = TRUE) %>%
  map(~keep(., str_detect, pattern = "uopp")) %>%
  flatten_chr() %>%
  map(rast) %>%
  map(crop, bbox) %>% 
  rast() %>% 
  interpolate_raster(source_time, target_time, "AD")
ggplot() + geom_spatraster(data = urb1, aes(fill = `AD1940`)) + 
  scale_fill_hypso_c(name = "Built-up\nareas\nkm2") + ggtitle("1940")
```

## Population count

However, I can expand beyond this strict definition of urbanization. I could plot out population counts instead:

```{r population count, warning=FALSE}
pop_rasters <- "~/Documents/Very_Large_Data/baseline/zip/" %>%
  list.files(full.names = TRUE, include.dirs = TRUE) %>%
  discard(str_detect, pattern = "\\.zip") %>%
  keep(str_detect, pattern = "pop") %>%
  map(list.files, full.names = TRUE) %>%
  map(~keep(., str_detect, pattern = "popc")) %>%
  flatten_chr() %>%
  map(rast) %>%
  map(crop, bbox)
urb2 <- rast(pop_rasters) %>% interpolate_raster(source_time, target_time, "AD")
ggplot() + geom_spatraster(data = urb2, aes(fill = `AD1941`)) + 
  scale_fill_paletteer_c("scico::devon", trans = "log10", name = "Population") + 
  ggtitle("1941")
```

## Other land use types

Hyde 3.2 also has data on cropland.

```{r cropland, message = F}
crop_rasters <- "~/Documents/Very_Large_Data/baseline/zip/" %>%
  list.files(full.names = TRUE, include.dirs = TRUE) %>%
  discard(str_detect, pattern = "\\.zip") %>%
  keep(str_detect, pattern = "lu") %>%
  map(list.files, full.names = TRUE) %>%
  map(~keep(., str_detect, pattern = "cropland")) %>%
  flatten_chr() %>%
  map(rast) %>%
  map(crop, bbox)
urb3 <- rast(crop_rasters) %>% interpolate_raster(source_time, target_time, "AD")
ggplot() + geom_spatraster(data = urb3, aes(fill = `AD1941`)) + 
  scale_fill_paletteer_c("scico::bamako", name = "Cropland\n(km2)") + 
  ggtitle("1941")
```

Here is cropland combined with urban areas:

```{r cropland + urban}
ggplot() + geom_spatraster(data = urb1 + urb3, aes(fill = `AD1941`)) +
  scale_fill_paletteer_c(`"pals::kovesi.linear_green_5_95_c69"`, direction = -1,
                         name = "Cropland\n+ urban\n(km2)") + 
  ggtitle("1941")
```

## Feeder density

I have data from Project FeederWatch from 1988 to 2020. This dataset has the disadvantage of not going back as far as the others, but the distinct advantage that it gets at what might be most relevant to house finches, which is bird feeder density.

```{r map bird feeders, message = F}
usa <- map_data("usa")
canada <- map_data("mapdata::worldHires", "Canada")
plan(multisession)
pfw <- "Data/Validation/FeederWatch" %>% here() %>% 
  list.files(pattern = "PFW", full.names = T) %>% 
  map(vroom, show_col_types = F) %>% 
  future_map(ZeroFillPFW, "houfin", rollup = F) %>% bind_rows()
pfw %>% group_by(LATITUDE, LONGITUDE) %>% 
  filter(Year==1997) %>% 
  summarize(Finches = if_else(sum(HOW_MANY)>0, "Present", "Absent")) %>% 
  ggplot() +
  geom_polygon(data = usa, 
               aes(x=long, y = lat, group = group), 
               fill = "gray50", 
               color="black") +
  geom_polygon(data = canada, aes(x=long, y = lat, group = group), 
               fill = "gray50", color="black") + 
  coord_quickmap(xlim = c(-140, -50), ylim = c(25, 55)) +
  geom_point(aes(x = LONGITUDE, y = LATITUDE, color = Finches), alpha = 0.6) +
  scale_color_paletteer_d("nbapalettes::huskies") + 
  ggtitle("House Finch Observations in 1996")
```

What I need to do is rasterize these data to my study region for the house finch, then count the number of feeders in each grid cell per year.

```{r rasterize feeder data}
region <- qs::qread(here("Data/Input/finch_region.qs"))
template <- rast(region$region_raster)
feeder_stack <- pfw %>% group_by(Year) %>% group_split() %>% 
  map(~group_by(., LATITUDE, LONGITUDE)) %>% 
  map(~summarize(., feeder_count = n(), .groups = "drop")) %>% 
  map(vect, geom = c("LONGITUDE", "LATITUDE"), crs = wgs84) %>% 
  map(project, crs(proj_crs)) %>% 
  map(rasterize, template, field = "feeder_count",
      background = 0, fun = sum) %>% 
  map(mask, template) %>% 
  rast() %>% 
  identity()
names(feeder_stack) <- 1988:2020 %>% map(~paste0("AD", .))
ggplot() + 
  geom_spatraster(data = feeder_stack, aes(fill = `AD1995`)) +
  scale_fill_paletteer_c(`"pals::ocean.solar"`,
                         name = "Bird Feeders", trans = "log1p") + 
  ggtitle("1995")
```

# Comparing Across Data Sources

I have presence data for house finches across a bunch of different sources, each of which may have its own spatial biases in observation across land use types. I want to extract data on the urbanization metrics above for all of the data sources in my dataset to better understand these biases.

First, let's look at the data sources.

```{r data sources}
hofi_sample <- vroom("~/Documents/Very_Large_Data/hofi_gbif_qc.tsv") %>% 
  filter(decimallongitude>-128, decimallongitude<(-61),
         decimallatitude>15, decimallatitude<54) %>%
  filter(year < 2018, year > 1987)
data_sources <- hofi_sample %>% pull(datasetkey) %>% unique() %>% 
  map(~datasets(uuid = .)) %>% 
  map("data") %>% map_chr("title") %>% 
  data.frame(Dataset = ., datasetkey = unique(pull(hofi_sample, datasetkey))) %>% 
  mutate(Source = c("Museum", "eBird", "Museum", "observation.org",
                    "iNaturalist", "Museum", "Museum", "Museum", "Museum", "Museum",
                    "naturgucker", "Museum", "Museum", "Sound library", 
                    "Park data", "Museum", "Museum", "Park data", "Park data", 
                    "Park data", "Museum", "Museum", "Museum", "Museum", 
                    "Park data", "Museum", "Museum", "Sequence data", "Museum",
                    "hatikka.fi", "Museum", "Sound library", "Sequence data",
                    "Museum", "Museum", "Great Backyard Bird Count", "Museum",
                    "MX govt data", "Park data", "Museum", "MX govt data", 
                    "BioBlitz", "Museum", "Museum", "Museum", "Museum", "BioBlitz",
                    "Museum", "MX govt data", "Ontario Breeding Bird Atlas",
                    "Museum", "Museum", "Museum", "MX govt data", "Park data",
                    "Museum", "Vermont Breeding Bird Atlas", "Sound library",
                    "Park data", "FinBIF", "Point Blue Conservation Science",
                    "Birda", "Museum", "Museum"))
hofi_sample <- hofi_sample %>% left_join(data_sources) %>% 
  mutate(Source = fct_lump_min(Source, 100))
hofi_sample %>% ggplot(aes(y = Source, fill = Source)) + 
  geom_bar() + 
  scale_x_log10(breaks = c(1, 10, 1000, 10000),
                labels = c(1, 10, 1000, 10000)) +
  scale_fill_paletteer_d(`"palettetown::natu"`) +
  theme(legend.position = "none") +
  xlab("Observations")
```

These are the ten categories I'm going to compare, which vary widely in number of observations.

```{r compare metrics}
points <- hofi_sample %>% arrange(year) %>% 
  group_by(year) %>% group_split() %>% 
  map(~select(., decimallongitude, decimallatitude)) %>% 
  map(sf_project, from = wgs84, to = proj_crs) %>% 
  map(as.data.frame) %>% 
  map(set_names, nm = c("lon", "lat")) %>% 
  map(vect, crs = crs(proj_crs)) %>% 
  identity()
urban_stack <- urb1 %>% project(template, "sum", threads = T) %>% 
  mask(template) %>% .[[49:78]]
pop_stack <- urb2 %>% project(template, "sum", threads = T) %>% 
  mask(template) %>% .[[49:78]]
crop_stack <- urb3 %>% project(template, "sum", threads = T) %>% 
  mask(template) %>% .[[49:78]]
feeder_stack <- feeder_stack[[1:30]]
var_names <- c("Urban", "Population", "Cropland", "Feeders")
extracts <- list(urban_stack, pop_stack, crop_stack, feeder_stack) %>% 
  map2(var_names, function(r, name) {
    map(1:30, function(i) {
      extract(r[[i]], points[[i]], ID = F) %>% set_names(c(name))
    }) %>% bind_rows()
  })
hofi_sample %>% arrange(year) %>% bind_cols(extracts) %>% 
  select(Source, all_of(var_names)) %>% 
  pivot_longer(var_names, names_to = "Metric", values_to = "Value") %>% 
  ggplot(aes(y = Source, x = Value, fill = Source)) + geom_boxplot() + 
  scale_fill_paletteer_d(`"palettetown::natu"`) +
  theme(legend.position = "none") +
  facet_wrap(~Metric, scales = "free_x")
```

The biases don't look too bad, especially when sample sizes are taken into account.

I also want to look at correlations, or lack thereof, between these different urbanization metrics.

```{r correlations}
hofi_sample %>% arrange(year) %>% bind_cols(extracts) %>%
  select(all_of(var_names)) %>% 
  GGally::ggscatmat()
```

# Urbanization and Probability of Occurrence

I aim to evaluate these metrics on their ability to estimate probability of occurrence in a SDM. According to my SDM based on strict urban land area, urbanization is a highly important predictor of occurrence and should be able to predict a lot on its own.

I will run the strict urban area SDM first because I have used that variable already in the full SDM, so I know it works for prediction.

```{r urban area sdm}
template <- rep(template, 30)
time(template, tstep = "years") <- c(1988:2017)
presences <- points %>% map(st_as_sf) %>% bind_rows() %>% 
  bind_cols(arrange(hofi_sample, year), extracts) %>% 
  mutate(time = parse_date_time(year, "%Y")) %>% 
  thin_by_cell_time(template)
absences <- sample_pseudoabs_time(presences, template, 1, return_pres = F) %>%
  group_by(time_step) %>% group_split() %>%
  imap(function(p, idx) {
    extract(urban_stack[[idx]], p, xy = T, ID = F) %>%
      left_join(extract(pop_stack[[idx]], p, xy = T, ID = F), by = c("x", "y")) %>%
      left_join(extract(crop_stack[[idx]], p, xy = T, ID = F), by = c("x", "y")) %>%
      left_join(extract(feeder_stack[[idx]], p, xy = T, ID = F), by = c("x", "y")) %>% set_names(c("Urban", "x", "y", "Population", "Cropland", "Feeders"))
  }) %>% 
  map(~mutate(., class = rep("pseudoabs"))) %>% 
  map2(parse_date_time(c(1988:2017), "%Y"), ~mutate(.x, time = rep(.y))) %>% 
  bind_rows() %>% 
  st_as_sf(coords = c("x", "y"), crs = proj_crs)
sdm_sample <- presences %>% 
  select(all_of(var_names), time, geometry) %>% 
  mutate(class = rep("presence")) %>% 
  bind_rows(absences) %>% 
  mutate(class = factor(class)) %>% 
  filter(!if_any(everything(), is.na)) %>% 
  spatial_initial_split(prop = 0.5, strategy = spatial_block_cv) %>% 
  identity()
urban_rec <- sdm_sample %>% 
  training() %>% 
  select(-time) %>% 
  recipe(formula = class ~ Urban)
urban_models <- workflow_set(
  preproc = list(default = urban_rec),
  models = list(
    rf = sdm_spec_rf(),
    gbm = sdm_spec_boost_tree(),
    glm = sdm_spec_glm()
  ),
  cross = T
) %>% 
  option_add(control = control_ensemble_grid())
urban_cv <- spatial_block_cv(training(sdm_sample), v = 5, method = "random")
urban_models <- urban_models %>%
  workflow_map("tune_grid", resamples = urban_cv, grid = 20, 
               metrics = sdm_metric_set(),
               verbose = TRUE)
urban_fit <- fit_best(urban_models, metric = "boyce_cont") %>% 
  last_fit(sdm_sample, metrics = sdm_metric_set())
pop_rec <- sdm_sample %>% 
  training() %>% 
  select(-time) %>% 
  recipe(formula = class ~ Population)
pop_models <- workflow_set(
  preproc = list(default = pop_rec),
  models = list(
    rf = sdm_spec_rf(),
    gbm = sdm_spec_boost_tree(),
    glm = sdm_spec_glm()
  ),
  cross = T
) %>% 
  option_add(control = control_ensemble_grid())
pop_models <- pop_models %>%
  workflow_map("tune_grid", resamples = urban_cv, grid = 20, 
               metrics = sdm_metric_set(),
               verbose = TRUE)
pop_fit <- fit_best(pop_models, metric = "boyce_cont") %>% 
  last_fit(sdm_sample, metrics = sdm_metric_set())
crop_rec <- sdm_sample %>% 
  training() %>% 
  select(-time) %>% 
  recipe(formula = class ~ Cropland)
crop_models <- workflow_set(
  preproc = list(default = crop_rec),
  models = list(
    rf = sdm_spec_rf(),
    gbm = sdm_spec_boost_tree()
  ),
  cross = T
) %>% 
  option_add(control = control_ensemble_grid())
crop_models <- crop_models %>%
  workflow_map("tune_grid", resamples = urban_cv, grid = 20, 
               metrics = sdm_metric_set(),
               verbose = TRUE)
crop_fit <- fit_best(crop_models, metric = "boyce_cont") %>% 
  last_fit(sdm_sample, metrics = sdm_metric_set())
feeder_rec <- sdm_sample %>% 
  training() %>% 
  select(-time) %>% 
  recipe(formula = class ~ Feeders)
feeder_models <- workflow_set(
  preproc = list(default = feeder_rec),
  models = list(
    rf = sdm_spec_rf(),
    gbm = sdm_spec_boost_tree()
  ),
  cross = T
) %>% 
  option_add(control = control_ensemble_grid())
feeder_models <- feeder_models %>%
  workflow_map("tune_grid", resamples = urban_cv, grid = 20, 
               metrics = sdm_metric_set(),
               verbose = TRUE)
feeder_fit <- fit_best(feeder_models, metric = "boyce_cont") %>% 
  last_fit(sdm_sample, metrics = sdm_metric_set())
list(urban = urban_fit, population = pop_fit, cropland = crop_fit, 
     feeders = feeder_fit) %>% 
  map(collect_metrics)
```

Human population count seems to do the best, though urban area does nearly as well.

# Urbanization and Conductance

I want to model the effects of urbanization on the conductance landscape (barriers and facilitators of dispersal on the landscape.) I have some empirical data on conductance in the form of occurrence records back to 1940, when the house finch was introduced to its invasive range.

If we consider the invasive range of the house finch, eastern North America, starting in the year of first occurrence, each grid cell will have a distance to the nearest grid cell occupied by house finches. That distance will decrease over time as the range expands. These slopes of decreasing distance to the house finch range frontier can be considered a metric of conductance if I control for distance from site of first introduction.

First let's look at occurrence over time in the invasive range.

```{r invasive range occurrences}
hofi_sample <- vroom("~/Documents/Very_Large_Data/hofi_gbif_qc.tsv") %>% 
  filter(decimallongitude>-128, decimallongitude<(-61),
         decimallatitude>15, decimallatitude<54) %>%
  filter(year < 2018, year > 1939) %>% 
  add_row(year = 1941, decimallatitude = 40.614167, 
          decimallongitude = -73.536111) %>% 
  add_row(year = 1944, decimallatitude = 40.641944, 
          decimallongitude = -73.694167)
points <- hofi_sample %>% 
    st_as_sf(coords = c("decimallongitude", "decimallatitude"), 
             crs = crs(wgs84)) %>% 
    st_transform(crs(proj_crs)) %>% 
  bind_cols(st_coordinates(.)) %>% 
  filter(X > (-333881), Y > (-1059959))
points %>% 
  filter(year %in% seq(1941, 2017, by = 15)) %>% 
  ggplot() +
  geom_spatraster(data = template[[1]] %>% is.na()) +
  scale_fill_paletteer_d("nbapalettes::rockets_city") +
  theme(legend.position = "none") +
  geom_sf(col = "white") + 
  xlim(-333881, 2638496) +
  ylim(-1059959, 2933161) +
  facet_wrap(~year)
```

Next, to get a better sense of conductance, I will determine the year of first sighting of house finches for each grid cell in the invasive range.

```{r year of first sighting}
first_sighting <- points %>% select(X, Y, year) %>% 
  rasterize(template, field = "year", fun = min)
ggplot() + 
  geom_spatraster(data = first_sighting, aes(fill = min)) +
  scale_fill_paletteer_c("pals::ocean.tempo", name = "First Sighted") +
  xlim(-333881, 2638496) +
  ylim(-1059959, 2933161)
```

Year of first sighting is one way to think about conductance, and one that I will revisit. But another way to think about it is as decreasing distance over time to the nearest finch-occupied cell.

Here I pick a grid cell at random from the invasive range and show a graph of its distance from the nearest finch-occupied grid cell over time.

```{r distance to finch occupied cell}
template <- template[[1]]
presence_thinned <- points %>%
  group_by(year) %>%
  group_split() %>%
  map_at(3:64, thin_by_cell, raster = template, coords = c("X", "Y"))
distances <- presence_thinned %>% 
  map(st_distance,
      st_as_sf(
        region$coordinates %>% filter(x > (-333881), y > (-1059959)),
        coords = c("x", "y"),
        crs = proj_crs
      ))
random_cell <- region$coordinates %>% filter(x > (-333881), y > (-1059959)) %>% 
  rownames_to_column("cell") %>% mutate(across(everything(), as.numeric)) %>% 
  sample_n(1)
ggplot() +
  geom_spatraster(data = template[[1]] %>% is.na()) +
  scale_fill_paletteer_d("nbapalettes::rockets_city") +
  theme(legend.position = "none") +
  geom_point(random_cell, mapping = aes(x, y), col = "white") +
  xlim(-333881, 2638496) +
  ylim(-1059959, 2933161) +
  ggtitle("Random cell")
distances %>% map(~.[,random_cell$cell]) %>% map_dbl(min, na.rm = T) %>% 
  data.frame(distance = ., Year = pull(points, year) %>% unique() %>% sort()) %>% 
  ggplot(aes(x = Year, y = distance)) + geom_line() + 
  geom_smooth(method = "lm") +
  ylab("Distance to nearest finch-occupied cell (m)") +
  ylim(0, NA)
```

There is a bunch of wiggle in here caused by erratic sightings in other cells. I think I can smooth this out by retaining grid cells that have ever had a finch sighting previously.

```{r distance to finch occupied cell 2}
points %>%
  group_by(year) %>%
  group_split() %>%
  map_at(3:64, thin_by_cell, raster = template, coords = c("X", "Y")) %>% 
  accumulate(bind_rows, .dir = "backward")
```
